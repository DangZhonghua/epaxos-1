// Code generated by protoc-gen-gogo.
// source: epaxos.proto
// DO NOT EDIT!

/*
	Package epaxospb is a generated protocol buffer package.

	It is generated from these files:
		epaxos.proto

	It has these top-level messages:
		Span
		Command
		Dependency
		InstanceMeta
		InstanceState
		PreAccept
		PreAcceptOK
		PreAcceptReply
		Accept
		AcceptOK
		Commit
		Ballot
		Message
*/
package epaxospb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Span represents a span of Keys that a Command operates on.
type Span struct {
	// The key for request. If the request operates on a range, this
	// represents the starting key for the range.
	Key Key `protobuf:"bytes,1,opt,name=key,proto3,casttype=Key" json:"key,omitempty"`
	// The end key is empty if the request spans only a single key. Otherwise,
	// it must order strictly after Key. In such a case, the header indicates
	// that the operation takes place on the key range from Key to EndKey,
	// including Key and excluding EndKey.
	EndKey Key `protobuf:"bytes,2,opt,name=end_key,json=endKey,proto3,casttype=Key" json:"end_key,omitempty"`
}

func (m *Span) Reset()                    { *m = Span{} }
func (*Span) ProtoMessage()               {}
func (*Span) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{0} }

func (m *Span) GetKey() Key {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Span) GetEndKey() Key {
	if m != nil {
		return m.EndKey
	}
	return nil
}

type Command struct {
	ID      uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Span    Span   `protobuf:"bytes,2,opt,name=span" json:"span"`
	Writing bool   `protobuf:"varint,3,opt,name=writing,proto3" json:"writing,omitempty"`
	Data    []byte `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{1} }

func (m *Command) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Command) GetSpan() Span {
	if m != nil {
		return m.Span
	}
	return Span{}
}

func (m *Command) GetWriting() bool {
	if m != nil {
		return m.Writing
	}
	return false
}

func (m *Command) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Dependency struct {
	ReplicaID   ReplicaID   `protobuf:"varint,1,opt,name=replica_id,json=replicaId,proto3,casttype=ReplicaID" json:"replica_id,omitempty"`
	InstanceNum InstanceNum `protobuf:"varint,2,opt,name=instance_num,json=instanceNum,proto3,casttype=InstanceNum" json:"instance_num,omitempty"`
}

func (m *Dependency) Reset()                    { *m = Dependency{} }
func (m *Dependency) String() string            { return proto.CompactTextString(m) }
func (*Dependency) ProtoMessage()               {}
func (*Dependency) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{2} }

func (m *Dependency) GetReplicaID() ReplicaID {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *Dependency) GetInstanceNum() InstanceNum {
	if m != nil {
		return m.InstanceNum
	}
	return 0
}

type InstanceMeta struct {
	Replica     ReplicaID   `protobuf:"varint,1,opt,name=replica,proto3,casttype=ReplicaID" json:"replica,omitempty"`
	InstanceNum InstanceNum `protobuf:"varint,2,opt,name=instance_num,json=instanceNum,proto3,casttype=InstanceNum" json:"instance_num,omitempty"`
}

func (m *InstanceMeta) Reset()                    { *m = InstanceMeta{} }
func (m *InstanceMeta) String() string            { return proto.CompactTextString(m) }
func (*InstanceMeta) ProtoMessage()               {}
func (*InstanceMeta) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{3} }

func (m *InstanceMeta) GetReplica() ReplicaID {
	if m != nil {
		return m.Replica
	}
	return 0
}

func (m *InstanceMeta) GetInstanceNum() InstanceNum {
	if m != nil {
		return m.InstanceNum
	}
	return 0
}

type InstanceState struct {
	Command *Command     `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
	SeqNum  SeqNum       `protobuf:"varint,2,opt,name=seq_num,json=seqNum,proto3,casttype=SeqNum" json:"seq_num,omitempty"`
	Deps    []Dependency `protobuf:"bytes,3,rep,name=deps" json:"deps"`
}

func (m *InstanceState) Reset()                    { *m = InstanceState{} }
func (m *InstanceState) String() string            { return proto.CompactTextString(m) }
func (*InstanceState) ProtoMessage()               {}
func (*InstanceState) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{4} }

func (m *InstanceState) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *InstanceState) GetSeqNum() SeqNum {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *InstanceState) GetDeps() []Dependency {
	if m != nil {
		return m.Deps
	}
	return nil
}

type PreAccept struct {
	InstanceState `protobuf:"bytes,1,opt,name=state,embedded=state" json:"state"`
}

func (m *PreAccept) Reset()                    { *m = PreAccept{} }
func (m *PreAccept) String() string            { return proto.CompactTextString(m) }
func (*PreAccept) ProtoMessage()               {}
func (*PreAccept) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{5} }

// PreAcceptOK is used to respond to a PreAccept message is cases where the
// remote replica has no new information about the proposed command.
type PreAcceptOK struct {
}

func (m *PreAcceptOK) Reset()                    { *m = PreAcceptOK{} }
func (m *PreAcceptOK) String() string            { return proto.CompactTextString(m) }
func (*PreAcceptOK) ProtoMessage()               {}
func (*PreAcceptOK) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{6} }

// PreAcceptReply is used to respond to a PreAccept message in cases whe the
// remote replica has new information about the proposed command. This new
// information may either be a larger sequence number or extra dependencies.
type PreAcceptReply struct {
	UpdatedSeqNum SeqNum       `protobuf:"varint,1,opt,name=updated_seq_num,json=updatedSeqNum,proto3,casttype=SeqNum" json:"updated_seq_num,omitempty"`
	UpdatedDeps   []Dependency `protobuf:"bytes,2,rep,name=updated_deps,json=updatedDeps" json:"updated_deps"`
}

func (m *PreAcceptReply) Reset()                    { *m = PreAcceptReply{} }
func (m *PreAcceptReply) String() string            { return proto.CompactTextString(m) }
func (*PreAcceptReply) ProtoMessage()               {}
func (*PreAcceptReply) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{7} }

func (m *PreAcceptReply) GetUpdatedSeqNum() SeqNum {
	if m != nil {
		return m.UpdatedSeqNum
	}
	return 0
}

func (m *PreAcceptReply) GetUpdatedDeps() []Dependency {
	if m != nil {
		return m.UpdatedDeps
	}
	return nil
}

type Accept struct {
	InstanceState `protobuf:"bytes,1,opt,name=state,embedded=state" json:"state"`
}

func (m *Accept) Reset()                    { *m = Accept{} }
func (m *Accept) String() string            { return proto.CompactTextString(m) }
func (*Accept) ProtoMessage()               {}
func (*Accept) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{8} }

type AcceptOK struct {
}

func (m *AcceptOK) Reset()                    { *m = AcceptOK{} }
func (m *AcceptOK) String() string            { return proto.CompactTextString(m) }
func (*AcceptOK) ProtoMessage()               {}
func (*AcceptOK) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{9} }

type Commit struct {
	InstanceState `protobuf:"bytes,1,opt,name=state,embedded=state" json:"state"`
}

func (m *Commit) Reset()                    { *m = Commit{} }
func (m *Commit) String() string            { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()               {}
func (*Commit) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{10} }

// Ballot is a ballot number that ensures message freshness.
type Ballot struct {
	Epoch     uint64    `protobuf:"varint,1,opt,name=Epoch,json=epoch,proto3" json:"Epoch,omitempty"`
	Number    uint64    `protobuf:"varint,2,opt,name=Number,json=number,proto3" json:"Number,omitempty"`
	ReplicaID ReplicaID `protobuf:"varint,3,opt,name=ReplicaID,json=replicaID,proto3,casttype=ReplicaID" json:"ReplicaID,omitempty"`
}

func (m *Ballot) Reset()                    { *m = Ballot{} }
func (m *Ballot) String() string            { return proto.CompactTextString(m) }
func (*Ballot) ProtoMessage()               {}
func (*Ballot) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{11} }

func (m *Ballot) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *Ballot) GetNumber() uint64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Ballot) GetReplicaID() ReplicaID {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

type Message struct {
	// to is the destination of the message.
	To ReplicaID `protobuf:"varint,1,opt,name=to,proto3,casttype=ReplicaID" json:"to,omitempty"`
	// ballot is the message's ballot number.
	Ballot Ballot `protobuf:"bytes,2,opt,name=ballot" json:"ballot"`
	// instance_meta holds information of the message's corresponding instance.
	InstanceMeta InstanceMeta `protobuf:"bytes,3,opt,name=instance_meta,json=instanceMeta" json:"instance_meta"`
	// type is a union of different message types.
	//
	// Types that are valid to be assigned to Type:
	//	*Message_PreAccept
	//	*Message_PreAcceptOk
	//	*Message_PreAcceptReply
	//	*Message_Accept
	//	*Message_AcceptOk
	//	*Message_Commit
	Type isMessage_Type `protobuf_oneof:"type"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorEpaxos, []int{12} }

type isMessage_Type interface {
	isMessage_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Message_PreAccept struct {
	PreAccept *PreAccept `protobuf:"bytes,4,opt,name=pre_accept,json=preAccept,oneof"`
}
type Message_PreAcceptOk struct {
	PreAcceptOk *PreAcceptOK `protobuf:"bytes,5,opt,name=pre_accept_ok,json=preAcceptOk,oneof"`
}
type Message_PreAcceptReply struct {
	PreAcceptReply *PreAcceptReply `protobuf:"bytes,6,opt,name=pre_accept_reply,json=preAcceptReply,oneof"`
}
type Message_Accept struct {
	Accept *Accept `protobuf:"bytes,7,opt,name=accept,oneof"`
}
type Message_AcceptOk struct {
	AcceptOk *AcceptOK `protobuf:"bytes,8,opt,name=accept_ok,json=acceptOk,oneof"`
}
type Message_Commit struct {
	Commit *Commit `protobuf:"bytes,9,opt,name=commit,oneof"`
}

func (*Message_PreAccept) isMessage_Type()      {}
func (*Message_PreAcceptOk) isMessage_Type()    {}
func (*Message_PreAcceptReply) isMessage_Type() {}
func (*Message_Accept) isMessage_Type()         {}
func (*Message_AcceptOk) isMessage_Type()       {}
func (*Message_Commit) isMessage_Type()         {}

func (m *Message) GetType() isMessage_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Message) GetTo() ReplicaID {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *Message) GetBallot() Ballot {
	if m != nil {
		return m.Ballot
	}
	return Ballot{}
}

func (m *Message) GetInstanceMeta() InstanceMeta {
	if m != nil {
		return m.InstanceMeta
	}
	return InstanceMeta{}
}

func (m *Message) GetPreAccept() *PreAccept {
	if x, ok := m.GetType().(*Message_PreAccept); ok {
		return x.PreAccept
	}
	return nil
}

func (m *Message) GetPreAcceptOk() *PreAcceptOK {
	if x, ok := m.GetType().(*Message_PreAcceptOk); ok {
		return x.PreAcceptOk
	}
	return nil
}

func (m *Message) GetPreAcceptReply() *PreAcceptReply {
	if x, ok := m.GetType().(*Message_PreAcceptReply); ok {
		return x.PreAcceptReply
	}
	return nil
}

func (m *Message) GetAccept() *Accept {
	if x, ok := m.GetType().(*Message_Accept); ok {
		return x.Accept
	}
	return nil
}

func (m *Message) GetAcceptOk() *AcceptOK {
	if x, ok := m.GetType().(*Message_AcceptOk); ok {
		return x.AcceptOk
	}
	return nil
}

func (m *Message) GetCommit() *Commit {
	if x, ok := m.GetType().(*Message_Commit); ok {
		return x.Commit
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Message) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Message_OneofMarshaler, _Message_OneofUnmarshaler, _Message_OneofSizer, []interface{}{
		(*Message_PreAccept)(nil),
		(*Message_PreAcceptOk)(nil),
		(*Message_PreAcceptReply)(nil),
		(*Message_Accept)(nil),
		(*Message_AcceptOk)(nil),
		(*Message_Commit)(nil),
	}
}

func _Message_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Message)
	// type
	switch x := m.Type.(type) {
	case *Message_PreAccept:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PreAccept); err != nil {
			return err
		}
	case *Message_PreAcceptOk:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PreAcceptOk); err != nil {
			return err
		}
	case *Message_PreAcceptReply:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PreAcceptReply); err != nil {
			return err
		}
	case *Message_Accept:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Accept); err != nil {
			return err
		}
	case *Message_AcceptOk:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AcceptOk); err != nil {
			return err
		}
	case *Message_Commit:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Commit); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Message.Type has unexpected type %T", x)
	}
	return nil
}

func _Message_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Message)
	switch tag {
	case 4: // type.pre_accept
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PreAccept)
		err := b.DecodeMessage(msg)
		m.Type = &Message_PreAccept{msg}
		return true, err
	case 5: // type.pre_accept_ok
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PreAcceptOK)
		err := b.DecodeMessage(msg)
		m.Type = &Message_PreAcceptOk{msg}
		return true, err
	case 6: // type.pre_accept_reply
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PreAcceptReply)
		err := b.DecodeMessage(msg)
		m.Type = &Message_PreAcceptReply{msg}
		return true, err
	case 7: // type.accept
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Accept)
		err := b.DecodeMessage(msg)
		m.Type = &Message_Accept{msg}
		return true, err
	case 8: // type.accept_ok
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AcceptOK)
		err := b.DecodeMessage(msg)
		m.Type = &Message_AcceptOk{msg}
		return true, err
	case 9: // type.commit
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Commit)
		err := b.DecodeMessage(msg)
		m.Type = &Message_Commit{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Message_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Message)
	// type
	switch x := m.Type.(type) {
	case *Message_PreAccept:
		s := proto.Size(x.PreAccept)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_PreAcceptOk:
		s := proto.Size(x.PreAcceptOk)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_PreAcceptReply:
		s := proto.Size(x.PreAcceptReply)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_Accept:
		s := proto.Size(x.Accept)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_AcceptOk:
		s := proto.Size(x.AcceptOk)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_Commit:
		s := proto.Size(x.Commit)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*Span)(nil), "epaxospb.Span")
	proto.RegisterType((*Command)(nil), "epaxospb.Command")
	proto.RegisterType((*Dependency)(nil), "epaxospb.Dependency")
	proto.RegisterType((*InstanceMeta)(nil), "epaxospb.InstanceMeta")
	proto.RegisterType((*InstanceState)(nil), "epaxospb.InstanceState")
	proto.RegisterType((*PreAccept)(nil), "epaxospb.PreAccept")
	proto.RegisterType((*PreAcceptOK)(nil), "epaxospb.PreAcceptOK")
	proto.RegisterType((*PreAcceptReply)(nil), "epaxospb.PreAcceptReply")
	proto.RegisterType((*Accept)(nil), "epaxospb.Accept")
	proto.RegisterType((*AcceptOK)(nil), "epaxospb.AcceptOK")
	proto.RegisterType((*Commit)(nil), "epaxospb.Commit")
	proto.RegisterType((*Ballot)(nil), "epaxospb.Ballot")
	proto.RegisterType((*Message)(nil), "epaxospb.Message")
}
func (m *Span) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Span) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	return i, nil
}

func (m *Command) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Command) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.ID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.Span.Size()))
	n1, err := m.Span.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Writing {
		dAtA[i] = 0x18
		i++
		if m.Writing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *Dependency) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Dependency) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.ReplicaID))
	}
	if m.InstanceNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceNum))
	}
	return i, nil
}

func (m *InstanceMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Replica != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Replica))
	}
	if m.InstanceNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceNum))
	}
	return i, nil
}

func (m *InstanceState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Command != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Command.Size()))
		n2, err := m.Command.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.SeqNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.SeqNum))
	}
	if len(m.Deps) > 0 {
		for _, msg := range m.Deps {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintEpaxos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PreAccept) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreAccept) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceState.Size()))
	n3, err := m.InstanceState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	return i, nil
}

func (m *PreAcceptOK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreAcceptOK) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *PreAcceptReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreAcceptReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UpdatedSeqNum != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.UpdatedSeqNum))
	}
	if len(m.UpdatedDeps) > 0 {
		for _, msg := range m.UpdatedDeps {
			dAtA[i] = 0x12
			i++
			i = encodeVarintEpaxos(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Accept) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Accept) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceState.Size()))
	n4, err := m.InstanceState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	return i, nil
}

func (m *AcceptOK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptOK) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceState.Size()))
	n5, err := m.InstanceState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	return i, nil
}

func (m *Ballot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ballot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Epoch))
	}
	if m.Number != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Number))
	}
	if m.ReplicaID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.ReplicaID))
	}
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.To != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.To))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.Ballot.Size()))
	n6, err := m.Ballot.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x1a
	i++
	i = encodeVarintEpaxos(dAtA, i, uint64(m.InstanceMeta.Size()))
	n7, err := m.InstanceMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.Type != nil {
		nn8, err := m.Type.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn8
	}
	return i, nil
}

func (m *Message_PreAccept) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PreAccept != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.PreAccept.Size()))
		n9, err := m.PreAccept.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *Message_PreAcceptOk) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PreAcceptOk != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.PreAcceptOk.Size()))
		n10, err := m.PreAcceptOk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}
func (m *Message_PreAcceptReply) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.PreAcceptReply != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.PreAcceptReply.Size()))
		n11, err := m.PreAcceptReply.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}
func (m *Message_Accept) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Accept != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Accept.Size()))
		n12, err := m.Accept.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *Message_AcceptOk) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.AcceptOk != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.AcceptOk.Size()))
		n13, err := m.AcceptOk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *Message_Commit) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Commit != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintEpaxos(dAtA, i, uint64(m.Commit.Size()))
		n14, err := m.Commit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func encodeFixed64Epaxos(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Epaxos(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintEpaxos(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Span) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovEpaxos(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}

func (m *Command) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovEpaxos(uint64(m.ID))
	}
	l = m.Span.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	if m.Writing {
		n += 2
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}

func (m *Dependency) Size() (n int) {
	var l int
	_ = l
	if m.ReplicaID != 0 {
		n += 1 + sovEpaxos(uint64(m.ReplicaID))
	}
	if m.InstanceNum != 0 {
		n += 1 + sovEpaxos(uint64(m.InstanceNum))
	}
	return n
}

func (m *InstanceMeta) Size() (n int) {
	var l int
	_ = l
	if m.Replica != 0 {
		n += 1 + sovEpaxos(uint64(m.Replica))
	}
	if m.InstanceNum != 0 {
		n += 1 + sovEpaxos(uint64(m.InstanceNum))
	}
	return n
}

func (m *InstanceState) Size() (n int) {
	var l int
	_ = l
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	if m.SeqNum != 0 {
		n += 1 + sovEpaxos(uint64(m.SeqNum))
	}
	if len(m.Deps) > 0 {
		for _, e := range m.Deps {
			l = e.Size()
			n += 1 + l + sovEpaxos(uint64(l))
		}
	}
	return n
}

func (m *PreAccept) Size() (n int) {
	var l int
	_ = l
	l = m.InstanceState.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	return n
}

func (m *PreAcceptOK) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *PreAcceptReply) Size() (n int) {
	var l int
	_ = l
	if m.UpdatedSeqNum != 0 {
		n += 1 + sovEpaxos(uint64(m.UpdatedSeqNum))
	}
	if len(m.UpdatedDeps) > 0 {
		for _, e := range m.UpdatedDeps {
			l = e.Size()
			n += 1 + l + sovEpaxos(uint64(l))
		}
	}
	return n
}

func (m *Accept) Size() (n int) {
	var l int
	_ = l
	l = m.InstanceState.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	return n
}

func (m *AcceptOK) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Commit) Size() (n int) {
	var l int
	_ = l
	l = m.InstanceState.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	return n
}

func (m *Ballot) Size() (n int) {
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovEpaxos(uint64(m.Epoch))
	}
	if m.Number != 0 {
		n += 1 + sovEpaxos(uint64(m.Number))
	}
	if m.ReplicaID != 0 {
		n += 1 + sovEpaxos(uint64(m.ReplicaID))
	}
	return n
}

func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.To != 0 {
		n += 1 + sovEpaxos(uint64(m.To))
	}
	l = m.Ballot.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	l = m.InstanceMeta.Size()
	n += 1 + l + sovEpaxos(uint64(l))
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *Message_PreAccept) Size() (n int) {
	var l int
	_ = l
	if m.PreAccept != nil {
		l = m.PreAccept.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}
func (m *Message_PreAcceptOk) Size() (n int) {
	var l int
	_ = l
	if m.PreAcceptOk != nil {
		l = m.PreAcceptOk.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}
func (m *Message_PreAcceptReply) Size() (n int) {
	var l int
	_ = l
	if m.PreAcceptReply != nil {
		l = m.PreAcceptReply.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}
func (m *Message_Accept) Size() (n int) {
	var l int
	_ = l
	if m.Accept != nil {
		l = m.Accept.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}
func (m *Message_AcceptOk) Size() (n int) {
	var l int
	_ = l
	if m.AcceptOk != nil {
		l = m.AcceptOk.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}
func (m *Message_Commit) Size() (n int) {
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovEpaxos(uint64(l))
	}
	return n
}

func sovEpaxos(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozEpaxos(x uint64) (n int) {
	return sovEpaxos(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Span) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Span: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Span: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Span.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Writing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Writing = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Dependency) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Dependency: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Dependency: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= (ReplicaID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceNum", wireType)
			}
			m.InstanceNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceNum |= (InstanceNum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			m.Replica = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Replica |= (ReplicaID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceNum", wireType)
			}
			m.InstanceNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceNum |= (InstanceNum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNum", wireType)
			}
			m.SeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNum |= (SeqNum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deps = append(m.Deps, Dependency{})
			if err := m.Deps[len(m.Deps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreAccept) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAccept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAccept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstanceState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreAcceptOK) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAcceptOK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAcceptOK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreAcceptReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreAcceptReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreAcceptReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedSeqNum", wireType)
			}
			m.UpdatedSeqNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedSeqNum |= (SeqNum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedDeps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedDeps = append(m.UpdatedDeps, Dependency{})
			if err := m.UpdatedDeps[len(m.UpdatedDeps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Accept) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Accept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Accept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstanceState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptOK) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptOK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptOK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstanceState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ballot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ballot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ballot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= (ReplicaID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= (ReplicaID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ballot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ballot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InstanceMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAccept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PreAccept{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_PreAccept{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAcceptOk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PreAcceptOK{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_PreAcceptOk{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreAcceptReply", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PreAcceptReply{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_PreAcceptReply{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Accept{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_Accept{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptOk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AcceptOK{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_AcceptOk{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEpaxos
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Commit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Message_Commit{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEpaxos(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthEpaxos
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEpaxos(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEpaxos
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEpaxos
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthEpaxos
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowEpaxos
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipEpaxos(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthEpaxos = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEpaxos   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("epaxos.proto", fileDescriptorEpaxos) }

var fileDescriptorEpaxos = []byte{
	// 760 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0xc1, 0x6e, 0xda, 0x4a,
	0x14, 0xc5, 0x60, 0x6c, 0xb8, 0x86, 0x24, 0x6f, 0x5e, 0x5e, 0x9e, 0x5f, 0xa4, 0x87, 0x11, 0x6f,
	0xf1, 0x50, 0xa2, 0x12, 0x95, 0x56, 0xaa, 0xda, 0xaa, 0x0b, 0x5c, 0x2a, 0x05, 0xa1, 0x24, 0x95,
	0xf3, 0x01, 0x68, 0xb0, 0xa7, 0xc4, 0x22, 0xd8, 0x13, 0x3c, 0xa8, 0x45, 0x5d, 0x74, 0xd1, 0x1f,
	0x68, 0x77, 0x5d, 0xf6, 0x73, 0xb2, 0xcc, 0x17, 0xa0, 0x8a, 0x2e, 0xfa, 0x0f, 0xac, 0xaa, 0x19,
	0x8f, 0xed, 0x90, 0x44, 0xaa, 0xd4, 0xac, 0xe2, 0x3b, 0x73, 0xce, 0xbd, 0xe7, 0xde, 0x39, 0x37,
	0x40, 0x85, 0x50, 0xfc, 0x2e, 0x8c, 0x5a, 0x74, 0x1a, 0xb2, 0x10, 0x95, 0xe2, 0x88, 0x0e, 0x77,
	0x1f, 0x8c, 0x7c, 0x76, 0x36, 0x1b, 0xb6, 0xdc, 0x70, 0x72, 0x30, 0x0a, 0x47, 0xe1, 0x81, 0x00,
	0x0c, 0x67, 0x6f, 0x44, 0x24, 0x02, 0xf1, 0x15, 0x13, 0x1b, 0x3d, 0x50, 0x4f, 0x29, 0x0e, 0xd0,
	0x3f, 0x50, 0x18, 0x93, 0xb9, 0xa9, 0xd4, 0x95, 0x66, 0xc5, 0xd6, 0x57, 0x0b, 0xab, 0xd0, 0x27,
	0x73, 0x87, 0x9f, 0xa1, 0x3a, 0xe8, 0x24, 0xf0, 0x06, 0xfc, 0x3a, 0xbf, 0x7e, 0xad, 0x91, 0xc0,
	0xeb, 0x93, 0xf9, 0x33, 0xf5, 0xcb, 0x57, 0x2b, 0xd7, 0xf8, 0x00, 0xfa, 0xcb, 0x70, 0x32, 0xc1,
	0x81, 0x87, 0x76, 0x20, 0xef, 0x7b, 0x22, 0x99, 0x6a, 0x6b, 0xcb, 0x85, 0x95, 0xef, 0x75, 0x9d,
	0xbc, 0xef, 0xa1, 0x26, 0xa8, 0x11, 0xc5, 0x81, 0xc8, 0x63, 0xb4, 0x37, 0x5a, 0x89, 0xea, 0x16,
	0xd7, 0x60, 0xab, 0x97, 0x0b, 0x2b, 0xe7, 0x08, 0x04, 0x32, 0x41, 0x7f, 0x3b, 0xf5, 0x99, 0x1f,
	0x8c, 0xcc, 0x42, 0x5d, 0x69, 0x96, 0x9c, 0x24, 0x44, 0x08, 0x54, 0x0f, 0x33, 0x6c, 0xaa, 0x5c,
	0x8b, 0x23, 0xbe, 0xa5, 0x80, 0xf7, 0x00, 0x5d, 0x42, 0x49, 0xe0, 0x91, 0xc0, 0x9d, 0xa3, 0xa7,
	0x00, 0x53, 0x42, 0xcf, 0x7d, 0x17, 0x0f, 0x52, 0x2d, 0xbb, 0xcb, 0x85, 0x55, 0x76, 0xe2, 0xd3,
	0x5e, 0x77, 0x75, 0x3d, 0x70, 0xca, 0x12, 0xdd, 0xf3, 0x50, 0x1b, 0x2a, 0x7e, 0x10, 0x31, 0x1c,
	0xb8, 0x64, 0x10, 0xcc, 0x26, 0x42, 0xae, 0x6a, 0x6f, 0xae, 0x16, 0x96, 0xd1, 0x93, 0xe7, 0xc7,
	0xb3, 0x89, 0x63, 0xf8, 0x59, 0xd0, 0x18, 0x43, 0x25, 0xb9, 0x3b, 0x22, 0x0c, 0xa3, 0xff, 0x41,
	0x97, 0x09, 0x65, 0xed, 0xea, 0x7a, 0xb9, 0xe4, 0xf6, 0xb7, 0x8a, 0x7d, 0x56, 0xa0, 0x9a, 0x5c,
	0x9e, 0x32, 0xcc, 0x08, 0xda, 0x07, 0xdd, 0x8d, 0x87, 0x2f, 0xca, 0x19, 0xed, 0x3f, 0xb2, 0xe1,
	0xca, 0x57, 0x71, 0x12, 0x04, 0xfa, 0x0f, 0xf4, 0x88, 0x5c, 0x5c, 0xab, 0x06, 0xab, 0x85, 0xa5,
	0x9d, 0x92, 0x0b, 0x5e, 0x48, 0x8b, 0xc4, 0x5f, 0xd4, 0x02, 0xd5, 0x23, 0x34, 0x32, 0x0b, 0xf5,
	0x42, 0xd3, 0x68, 0x6f, 0x67, 0xe9, 0xb2, 0x19, 0x27, 0x2f, 0xc6, 0x71, 0x8d, 0x2e, 0x94, 0x5f,
	0x4f, 0x49, 0xc7, 0x75, 0x09, 0x65, 0xe8, 0x09, 0x14, 0x23, 0xae, 0x4b, 0x8a, 0xf9, 0x3b, 0x63,
	0xaf, 0xc9, 0xb6, 0x4b, 0x3c, 0xc1, 0xd5, 0xc2, 0x52, 0x9c, 0x18, 0xdf, 0xa8, 0x82, 0x91, 0x66,
	0x39, 0xe9, 0x37, 0x3e, 0x2a, 0xb0, 0x91, 0xc6, 0x7c, 0x78, 0x73, 0xd4, 0x86, 0xcd, 0x19, 0xf5,
	0x30, 0x23, 0xde, 0x20, 0x69, 0x42, 0xb9, 0xd5, 0x44, 0x55, 0x42, 0xe2, 0x10, 0xbd, 0x80, 0x4a,
	0xc2, 0x11, 0x3d, 0xe5, 0x7f, 0xd9, 0x93, 0x21, 0xf1, 0x5d, 0xde, 0x5a, 0x07, 0xb4, 0xfb, 0xf6,
	0x05, 0x50, 0x4a, 0x9b, 0xea, 0x80, 0xc6, 0x9f, 0xc4, 0xbf, 0x47, 0x3a, 0x17, 0x34, 0x1b, 0x9f,
	0x9f, 0x87, 0x0c, 0x6d, 0x43, 0xf1, 0x15, 0x0d, 0xdd, 0xb3, 0x78, 0x08, 0x4e, 0x91, 0xf0, 0x00,
	0xed, 0x80, 0x76, 0x3c, 0x9b, 0x0c, 0xc9, 0x34, 0x7e, 0x60, 0x47, 0x0b, 0x44, 0x84, 0xf6, 0x21,
	0xb3, 0xa0, 0x58, 0xac, 0x5b, 0xbe, 0x4c, 0xd7, 0xa0, 0xdb, 0xf8, 0x51, 0x00, 0xfd, 0x88, 0x44,
	0x11, 0x1e, 0x11, 0xf4, 0x2f, 0xe4, 0x59, 0x78, 0xb7, 0x93, 0xf3, 0x2c, 0x44, 0x2d, 0xd0, 0x86,
	0x42, 0x8f, 0x5c, 0xed, 0xad, 0xac, 0x93, 0x58, 0xa7, 0x1c, 0xab, 0x44, 0xa1, 0x0e, 0x54, 0x53,
	0xd3, 0x4f, 0x08, 0xc3, 0x42, 0x8b, 0xd1, 0xde, 0xb9, 0x3d, 0x00, 0xbe, 0x4c, 0x92, 0x9c, 0xee,
	0x89, 0x58, 0xb0, 0xc7, 0x00, 0x74, 0x4a, 0x06, 0x58, 0x4c, 0x55, 0xfc, 0x37, 0x30, 0xda, 0x7f,
	0x66, 0xfc, 0xd4, 0x35, 0x87, 0x39, 0xa7, 0x4c, 0x53, 0x63, 0x3e, 0x87, 0x6a, 0xc6, 0x1a, 0x84,
	0x63, 0xb3, 0x28, 0x88, 0x7f, 0xdd, 0x41, 0x3c, 0xe9, 0x1f, 0xe6, 0x1c, 0x23, 0xa5, 0x9e, 0x8c,
	0x51, 0x17, 0xb6, 0xae, 0x91, 0xf9, 0xa0, 0xe6, 0xa6, 0x26, 0xf8, 0xe6, 0x1d, 0x7c, 0x61, 0xd7,
	0xc3, 0x9c, 0xb3, 0x41, 0xd7, 0x0d, 0xbc, 0x07, 0x9a, 0x14, 0xad, 0xdf, 0x9c, 0x55, 0xaa, 0x58,
	0x22, 0xd0, 0x43, 0x28, 0x67, 0x52, 0x4b, 0x02, 0x8e, 0x6e, 0xc2, 0x85, 0xce, 0x12, 0x4e, 0x44,
	0xee, 0x81, 0xe6, 0x0a, 0x77, 0x99, 0xe5, 0x9b, 0xe9, 0x63, 0xd7, 0xf1, 0xf4, 0x31, 0xc2, 0xd6,
	0x40, 0x65, 0x73, 0x4a, 0xec, 0xad, 0xcb, 0x65, 0x4d, 0xb9, 0x5a, 0xd6, 0x94, 0x6f, 0xcb, 0x9a,
	0xf2, 0xe9, 0x7b, 0x2d, 0x37, 0xd4, 0xc4, 0xcf, 0xc3, 0xa3, 0x9f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x9d, 0x4f, 0x76, 0x83, 0x67, 0x06, 0x00, 0x00,
}
